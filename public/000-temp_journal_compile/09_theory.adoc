:source-highlighter: highlightjs
:highlightjsdir: highlight
//URLS
:url-ruby-webassembly: https://www.youtube.com/watch?v=yHFMvfuEBSk
:url-why-poignant-guide: http://poignant.guide/
:url-dependency-injection-java: https://www.codejava.net/coding/what-is-dependency-injection-with-java-code-example
:url-well-grounded-ruby: https://www.manning.com/books/the-well-grounded-rubyist

= *Theory*

[.normal]
To keep things relatively clear, I will try to stick to Ruby language for this survey of basic theory in programming.
I'll talk about other languages vaguely, however, as I find that sometimes it's easier for me to consider certain concepts in other languages - it's sometimes the case that I haven't explicitly encountered such and such a concept in Ruby. But I'm often reminded by my mentor that that doesn't mean it doesn't exist in Ruby.
Ruby is commonly known by the community as being "very expressive", perhaps that's because it's dynamically typed, or because objects (as we'll momentarily see) can be coerced. We can change things at the language level.
It might also be that, in Ruby, there are _many many many_ ways to do anything and everything.

Ruby was invented by a lovely Japanese man - Yukihiro Matsumoto.
The idea was/is to have a language that is not only "really expressive", but also really simple.
That doesn't mean simplistic, however, since we can do all manner or complex things, like {url-ruby-webassembly}[this WebAssembly interpreter].

The simplicity of Ruby contributes to the idiomatic nature of it, meaning it reads slightly like natural language - it's design is such that even a non-programmer can understand more or less what is happening.
To get a really nice primer in Ruby through fun and inspiring reading see {url-why-poignant-guide}[_Why's Poignant Guide_].
For something more serious see {url-well-grounded-ruby}[_The Well Grounded Rubyist_]

== Language paradigms

There are two big familias of programming paradigms:

1. _Declarative Programming Paradigm_
- Logic Programming Paradigm
- Functional Programming
- Databbase Processing

2. _Imperative Programming Paradigm_
- Procedural programming Paradigm
- Object Oriented Programming
- Parallel Processing Approach

Ruby falls into the Object Oriented Programming Paradigm, since everything is an object - well, almost everything... actually not quite, but let's pretened for now.

.*What is an object?*
[%collapsible]
====
****
An instance of a class. To some it's also the root class in ruby (Object).
Clases themselves descend from the Object root class.

Things that an object might have:
- identity (object identifier)
- State
- Behaviour

In the real world:
- A Dog, has state (colourm breed, name, hungry) and behaviour (barking, fetching, wagging tail)
- A bike has state (current gear, current pedal cadence, current speed), behaviours (changing gear, changing pedal cadence, applying brakes)
****
====

=== What is OOP?

OOP is defined as a programming paradigm that relies on the concept of classes
and objects.

Here's a brief overview of what you can achieve with OOP: you can use it to
structure a software program into simple, reusable code blocks (in this case
usually called classes), which you then use to create individual instances of
sss objects.

_*The four pillars of OOP:*_
  1. Abstraction
  2. Encapsulation
  3. Polymorphism
  4. Inheritance

==== _Abstraction_

.*What is abstraction?*
[%collapsible]
====
****
To abstract something away means to hide away the implementation details inside
something – sometimes a prototype, sometimes a function. So when you call the
function you don't have to understand exactly what it is doing.
****
====

==== _Encapsulation_

The definition of encapsulation is "the action of enclosing something in or as
if in a capsule". Removing access to parts of your code and making things
private is exactly what Encapsulation is all about (often times, people refer
to it as data hiding).

.*What is encapsulation?*
[%collapsible]
====
****
Encapsulation in OOPs may also mean restricting direct access to certain
components of an object so that users can't access the state values for all
variables of a particular object.  Therefore, encapsulation can be used to hide
data members and functions associated with an instantiated class or object.
Encapsulation is analogous to a capsule where the mixture of medicines inside
the pill represents the data and methods while the hard outer shell could be
though of as the class.

The concept of binding fileds (object state) and methods (behaviour) together as a single unit.

Programming languages such as Java use *encapsulation* in the form of classes. A
class allows programmers to create objects with variables (data) and behaviours
(methods or functions). Since a class consists of data and methods *packed into
a single unit*, it is an example of encapsulation.

****
====

.*How is encapsulation different from abstraction?*
[%collapsible]
====
****
.Key Difference
- Abstraction shows only useful data by providing the most necessary details
whereas Encapsulation wraps code and data for necessary information.
- Abstraction is focused mainly on *_what_* should be done while Encapsulation is
focused on *_how_* it should be done.
- Abstraction hides complexity by giving you a more abstract picture while
Encapsulation hides internal working so that you can change it later.
- Abstraction helps you partition the program into many independent portions
whereas Encapsulation is easy to change with new requirements.
- Comparing Encapsulation vs Abstraction, Abstraction solves problem at design level while
Encapsulation solves problem at implementation level.
- Abstraction hides the irrelevant details found in the code whereas Encapsulation helps developers to
organize the entire code easily.
****
====

==== _Polymorphism_

.*What is polymorphism?*
[%collapsible]
====
****
Polymorphism means "the condition of occurring in several different forms."
That's exactly what the fourth and final pillar is concerned with – types in
the same inheritance chains being able to do different things.

The real power of polymorphism is sharing behaviours, and allowing custom
overrides.
****
====

And finally...

==== _Inheritance_


.*What is inheritance?.*
[%collapsible]
====
****
Inheritance lets one object acquire the properties and methods of another
object. In JavaScript this is done by Prototypal Inheritance.

Reusability is the main benefit here. We know sometimes that multiple places
need to do the same thing, and they need to do everything the same except for
one small part. This is a problem inheritance can solve.

This is where we can think about Liskov Substitution principle.
****
====

.*What do we mean by prototypical inheritance?*
[%collapsible]
====
****
In short, it is the assignement of the behaviours of one object to another, in
the case we're we do not define the behaviours or datasets belonging to a new
object we create. It is the extension of the behaviours of one object that we
call the prototype to other objects.

In programming, we might want to take something and extend it.

For instance, we have a user object with its properties and methods, and want to make `admin` and `guest` as slighly modified variants of it.
We'd like to reuse what we have in `user`, not copy/reimplement its methods, just build a new object on top of it.

*Prototypal inheritance* is a language feature that helps in that.
****
====
In Ruby classes and modules are two object types that allow us to do this to extend "meaning" or "structure" beyond onto other programmable things.
We also have other tactics, such as the `extend` keyword. (Perhaps later we will have an example.)

==== What is a Class?
[%collapsible]
====
****
If we need to build a new data type, we need to write a class for it. This
class *serves as a blueprint* or *template* for your *new data type*.

It's important because it *lets us know what things can belong within this data type,
and perhaps more importantly what behaviours or routine behaviours belong on that class*.
A class groups data and member functions/methods that work on those data
members. Thus a class groups data and functions related to each other. We call
it data encapsulation in technical language.
****
====

==== What is a Module?

A Module is a collection of methods, constants, and class variable. Modules are
defined as a class, but with the *module* keyword not with class keyword.

*_Basically a library of sorts, where we can store data types-like with a class,
except we dont instantiate an instance of a module._*

*_Modules are about providing methods that you can use across multiple classes -
think about them as "librairies" (as you would see in a Rails app). Classes are
about objects; modules are about functions._*

You might also use a module when you have shared methods across multiple apps
(again, the library model is good here).  Answer taken from


Important points about Modules:

- You cannot inherit modules or you can't create a subclass of a module.
- Objects cannot be created from a module.
- Modules are used as namespaces and as mixins.
- All the classes are modules, but all the modules are not classes.
- The class can use namespaces, but they cannot use mixins like modules.
- The name of a module must start with a capital letter.

.Syntax:
[source, ruby]
----
module Module_name
  # statements to be executed
end
----
.Example:
[source, ruby]
----
# Ruby program to illustrate the module
# Creating a module with name Gfg

module Gfg

  C = 10;

  # Prefix with name of Modul
  # module method
  def Gfg.portal
    puts "Welcome to GFG Portal!"
  end

  # Prefix with the name of Module
  # module method
  def Gfg.tutorial
    puts "Ruby Tutorial!"
  end

  # Prefix with the name of Module
  # module method
  def Gfg.topic
    puts "Topic - Module"
  end
end

# displaying the value of
# module constant

puts Gfg::C

# calling the methods of the module
Gfg.portal
Gfg.tutorial
Gfg.topic
----

.Output
[source, ruby]
----
10
Welcome to GFG Portal!
Ruby Tutorial!
Topic - Module
----

*Note:*
- To define module method the user has to prefix the name of the module with the
  method name while defining the method. The benefit of defining module method
  is that use can call this method by simply using the name of module and dot
  operator as shown in above example.
- A user can access the value of a module constant by using the double colon
  operator(::) as show in the above example.
- If the user will define a method with def keyword only inside a module _i.e.
  def method_name_ then it will consider an an instance method. A user cannot
  access instance method directly with the use of the dot operator as he cannot
  make the instance of the module.
- To access the instance method defined inside the module, the user has to
  include the module inside a class and then use the class instance to access
  that method. Below example illustrates this concept clearly.
- The user can use the module inside the class by usingg _include_ keyword. In
  this case, the module works like a namespace.

.Example
[source, ruby]
----
# Ruby program to illustrate how
# to use module inside a class

# Creating a module with name Gfg
module Gfg

  # module method
  def portal
    puts "Welcome to GFG Portal!"
  end

  # module method
  def tutorial
    puts "Ruby Tutorial!"
  End2Endd

  # module method
  def topic
    puts "Topic - Module"
  end

end


# Create class
class GeeksforGeeks

  # Include module in class
  # by usingg 'include' keyword
  include Gfg

  # Method of the class
  def add
    x = 30 + 20
    puts x
  end

end

# Creating objects of class
obj_class = GeeksforGeeks.new

# calling module methods
# with the help of GeeksforGeeksorGeeks
# class object
obj_class.portal
obj_class.tutorial
obj_class.topic

# Calling class method
obj_class.add
----

*Use of Modules:*
A module is a way to categorize the methods and constants so
that user can reuse them Suppose he wants to write two methods and also wants
to use these methods in multiple programs. So, in this case they can write
these methods in a module, so that they can easily call this module in any
program with the help of require keyword without re-writing code.

.*What is the difference between a class and a module?*
[%collapsible]
====
****
Modules serve as a mechanism for namespaces.

[source, ruby]
----
module ANamespace
  class AClass
    def initialize
      puts "Another object, coming right up!"
  end
end

ANamespace::AClass.new
 #=> Another object, coming right up!
----

Also, modules provide as a mechanism for multiple inheritance via mix-ins and
cannot be instantiated like classes can.
[source, ruby]
----
module AMixIn
 def who_am_i?
   puts "An existntialist, that's who."
 end
end


# String is already the parent class
class DeepString < String
  # extends adds instance methods from AMixIn as class methods
  extend AMixIn
end

DeepString.who_am_i?
#=> An existentialist, that's who.

AMixIn.new
#=> NoMethodError: undefined method 'new' for AMixIn:Module
----

|===
|| class | module

|_instantiation_
|can be instantiated
|can *not* be instantiated

|_usage_
|object creation
|mixin facility. provide a namespace.

|_superclass_
|module
|object

|_methods_
|class methods and instance methods
|module methods and instance methods

|_inheritance_
|inherits behaviour and can be base for inheritance
|No inheritance

|_inclusion_
|cannot be included
|can be included in classes and modules by using the include command (includes
all instance methods as instance methods in a class/module)

|_extension_
|can not extend with extend command (only with inheritance)
|module can extend instance by using extend command (extends given instance with singleton methods from module)

|===

_Another explanation._

A Module is a collection of methods, constants, and class variable. Modules are
defined as a class, but with the *module* keyword not with class keyword.

Important points about Modules:

- You cannot inherit modules or you can't create a subclass of a module.
- Objects cannot be created from a module.
- Modules are used as namespaces and as mixins.
- All the classes are modules, but all the modules are not classes.
- The class can use namespaces, but they cannot use mixins like modules.
- The name of a module must start with a capital letter.

.Syntax:
[source, ruby]
----
module Module_name
  # statements to be executed
end
----
.Example:
[source, ruby]
----
# Ruby program to illustrate the module
# Creating a module with name Gfg

module Gfg

  C = 10;

  # Prefix with name of Modul
  # module method
  def Gfg.portal
    puts "Welcome to GFG Portal!"
  end

  # Prefix with the name of Module
  # module method
  def Gfg.tutorial
    puts "Ruby Tutorial!"
  end

  # Prefix with the name of Module
  # module method
  def Gfg.topic
    puts "Topic - Module"
  end
end

# displaying the value of
# module constant

puts Gfg::C

# calling the methods of the module
Gfg.portal
Gfg.tutorial
Gfg.topic
----

.Output
[source, ruby]
----
10
Welcome to GFG Portal!
Ruby Tutorial!
Topic - Module
----

*Note:*
- To *define a module method* the user has to prefix the name of the module with the
  method name while defining the method. The benefit of defining a module method
  is that the user can call this method by simply using the name of module and dot
  operator as shown in above example.
- A user can access the value of a module constant by using the double colon
  operator(::) as show in the above example.
- If the user will define a method with def keyword only inside a module _i.e.
  def method_name_ then it will consider an an instance method. A user cannot
  access instance method directly with the use of the dot operator as he cannot
  make the instance of the module.
- To access the instance method defined inside the module, the user has to
  include the module inside a class and then use the class instance to access
  that method. Below example illustrates this concept clearly.
- The user can use the module inside the class by usingg _include_ keyword. In
  this case, the module works like a namespace.

.Example
[source, ruby]
----
# Ruby program to illustrate how
# to use module inside a class

# Creating a module with name Gfg
module Gfg

  # module method
  def portal
    puts "Welcome to GFG Portal!"
  end

  # module method
  def tutorial
    puts "Ruby Tutorial!"
  End2Endd

  # module method
  def topic
    puts "Topic - Module"
  end

end


# Create class
class GeeksforGeeks

  # Include module in class
  # by usingg 'include' keyword
  include Gfg

  # Method of the class
  def add
    x = 30 + 20
    puts x
  end

end

# Creating objects of class
obj_class = GeeksforGeeks.new

# calling module methods
# with the help of GeeksforGeeksorGeeks
# class object
obj_class.portal
obj_class.tutorial
obj_class.topic

# Calling class method
obj_class.add
----

*Use of Modules:*
A module is a way to categorize the methods and constants so
that user can reuse them Suppose he wants to write two methods and also wants
to use these methods in multiple programs. So, in this case they can write
these methods in a module, so that they can easily call this module in any
program with the help of require keyword without re-writing code.
****
====

== _Strong-typed_ vs _Dynamically-typed_

Ruby is dynamically typed since type checking is done at runtime,
unlike languages like C# and Java, that both have type-safety.
Having type-safety means we have to declare what type of values a variable can have, what type of data it can hold (i.e. whether it is `string` or `integer`, for instance). The reason for this is that if we have a method that is alleged to do some mathematical calculation on a given argument, then we need to know it's _safe_ to do so, we need to know it's possible. We can't, for instance, have a method (a routine operation) say:

[source, ruby]
----
def method(argument)
  # take whatever the `argument` is and multiply it by 3
  # take the result of that and add to it the number 47
end
----
If we pass as an argument to this method the word (of type _string_) "duck", then we will receive an error message at run-time because we cannot operate numerically on string, we can only do so on an _integer_, or in Ruby _float_
To avoid this sort of thing we therefore have *type safety*.

The type-saftey catch for JavaScript is known as TypeScript.
The benefit of type safety is that any errors are caught before compiling, because these scripting languages require compilation ("building") before the code can be executed. Unlike these, Ruby compiles at run time however, and has something called duck-typing.

.*What is duck typing and how does it pertain to Ruby?*
[%collapsible]
====
****
That an object may be acted upon even if it isn't expected type as long as it
looks and behaves like the expected object. This is a characteristic of Ruby
because the lack of type checking of parameters makes this an effective
programming technique.
_If it sounds like a duck, and walks like a duck, it
must be a duck; object types are inferred and not declared_
****
====

How can duck typing be useful? Let's think about "coercion" in programming:

.*What does it mean to coerce an object? Why would you do it?*
[%collapsible]
====
****
To *_coerce an object_* means to force it into an expected type. One migt do
this in order to try and force an unknown object type into the expected type or
format required by the operation. This is a common practice ivolved in _duck
typing_.
****
====

== SOLID principles

====
****
1. S - *Single Responsibility Principle* (SRP): "one and only one responsibility."
2. O - *Open/Close Principle*: "open for extension but closed for modification."
3. L - *Liskov's Substitution Principle*: "parent classes should be easily substituted with their child classes without blowing up the application."
4. I - *Interface Segregation Principle*: "many client specific interfaces are better than one general interface."
5. D - *Dependency Inversion Principle*: "classes should depend on abstraction, but not on concretion."
****
====

[insert oldPhonePad challenge at this commit message:
commit f3db652a682affb447974ed40308e65413a00120 (HEAD -> unbroken, main/unbroken)
Author: benjamin <b.james.neustadt@gmail.com>
Date:   Thu Oct 13 09:49:50 2022 +0200]

.SOLID principles in Ruby
[source, ruby]
----
Letters = {
  "1"    => '&',
  "11"   => "'",
  "111"  => '(',
  "0"    => ' ',
  "2"    => 'A',
  "22"   => 'B',
  "222"  => 'C',
  "3"    => 'D',
  "33"   => 'E',
  "333"  => 'F',
  "4"    => 'G',
  "44"   => 'H',
  "444"  => 'I',
  "5"    => 'J',
  "55"   => 'K',
  "555"  => 'L',
  "6"    => 'M',
  "66"   => 'N',
  "666"  => 'O',
  "7"    => 'P',
  "77"   => 'Q',
  "777"  => 'R',
  "7777" => 'S',
  "8"    => 'T',
  "88"   => 'U',
  "888"  => 'V',
  "9"    => 'W',
  "99"   => 'X',
  "999"  => 'Y',
  "9999" => 'Z',
  }

def oldphone(str)
  result = str.scan(/0+|1+|2+|3+|4+|5+|6+|7+|8+|9+|\*/)
  while result.include? '*'
    result.delete_at(result.index('*') - 1)
    result.delete_at(result.index('*'))
  end
  translation = result.map {|digit_input| Letters[digit_input]}
  translation.join
end
----

This was the state of our solution; all the logic is held inside one method.
ALthough it passes, and solves the task at hand, it is not well structured, as
is does not respect the single responsibility principle.

After we change it, this is what we come up with:

[source, ruby]
----
require_relative 'transform.rb' <1>

def oldphone(str)
  Transform.new(str).to_s       <2>
end
----

<1> We call in the 'transfrom.rb' file so that we can create an instance of
that class, upon using the `oldphonepad` method.

<2> The method is entirely sanitized, holding as little as necessary to make it
function; here it is clearer that it calls another function behind the scenes.

[source, ruby]
----
module RegularExpressions
  module Dictionary
  RegularExpression = {
    repeating_digits: /0+|1+|2+|3+|4+|5+|6+|7+|8+|9+|\*/   <1>
  }
  end
end

class Transform
  include RegularExpressions::Dictionary                   <2>

  Keypad_Morpheme = {                                      <3>
    "1"    => '&',
    "11"   => "'",
    "111"  => '(',
    "0"    => ' ',
    "2"    => 'A',
    "22"   => 'B',
    "222"  => 'C',
    "3"    => 'D',
    "33"   => 'E',
    "333"  => 'F',
    "4"    => 'G',
    "44"   => 'H',
    "444"  => 'I',
    "5"    => 'J',
    "55"   => 'K',
    "555"  => 'L',
    "6"    => 'M',
    "66"   => 'N',
    "666"  => 'O',
    "7"    => 'P',
    "77"   => 'Q',
    "777"  => 'R',
    "7777" => 'S',
    "8"    => 'T',
    "88"   => 'U',
    "888"  => 'V',
    "9"    => 'W',
    "99"   => 'X',
    "999"  => 'Y',
    "9999" => 'Z',
  }

  RE = RegularExpression                                   <4>
  private_constant :RE

  private

  attr_reader :message

  def initialize(encoded_message)
    @message = encoded_message.scan(RE[:repeating_digits])
    deletions
  end

  def deletions
    while message.include? '*'
      message.delete_at(message.index('*') - 1)
      message.delete_at(message.index('*'))
    end
  end

  def translate
    message.each_with_object('') do |encoding, memo|
      memo << Keypad_Morpheme[encoding]
    end
  end

  public

  def to_s
    translate
  end

end

# Library Guard
if $0 == __FILE__
  puts Transform.new('22 28')
end
----

<1> module including the regular expression, what could be one of many
<2> We bring in the module to the class
<3> We bring in the constant to the class
<4> We assign an abbreviation to the regular expression, only once we have called it previously.

All of the methods are separated at granular level, so that each method is only
dealing with one portion of the program's functionality.

=== Single Responsibility Principle

=== Open/Close Principle

=== Liskov's Substitution Principle

=== Interface Segregation Principle

=== Dependency Inversion Principle

.*What is inversion control/dependency injection*?*
[%collapsible]
====
****
Any nontrivial application is made up of two or more classes that collaborate
with each other to perform some business logic. Traditionally, each object is
responsible for obtaining its own references to the objects it collaborates
with (its dependencies). When applying DI, the objects are given their
dependencies at creation time by some external entity that coordinates each
object in the system. In other words, dependencies are injected into objects.

Here is an example using Java:

.Normally a class will depend on another class to do some work, such as above.
[source, csharp]
----
public class ClientA {
    ServiceB service;

    public void doSomething() {
        String info = service.getInfo();
    }
}
----

.`ClientA` uses class `ServiceB` which is written below:
[source, csharp]
----
public class ServiceB {
    public String getInfo() {
        return "ServiceB’s Info";
    }
}
----

* `ClientA` is said to be dependent on class `ServiceB`, which is thereby called a dependency of `ClientA`. This kind of dependency is trivial, though if the code gets bigger and more complex, hard.

To Be Continued...

* resource: https://www.infoworld.com/article/2071914/excellent-explanation-of-dependency-injection-&ndash;inversion-of-control-.html[dependency injection]
* resource: {url-dependency-injection-java}[dependency injection]

****
====

