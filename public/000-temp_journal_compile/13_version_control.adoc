= *Git Version Control*
:source-language: shell
//URLS
:url-citizen428-article: https://www.codementor.io/@citizen428/git-tutorial-10-common-git-problems-and-how-to-fix-them-aajv0katd

* *resource*: https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control/[Alot of the info was found here]
* *resource*: https://git-scm.com/book/en/v2[The indepth documentation is here]

Articles to read:

- {url-citizen428-article}[Git Tutorial: 10 Common Git Problems and How to Fix Them]


Git is a free and open source version control system.
https://github.com/[Github] is the centralised hub that allows the remote storage of all things Git related. It is a type of Centralized Version Control System(CVCS), this is the standard for version control.

If Git is a version control system that for tracking change.

There are alternatives to Github, like sourcehut, Gitlab; but one could also build a personalized server to host versions remotely for team members to use.
Github is nice for various reasons. It has a GUI interface, and there are social aspects to it that allows users to share their code with a larger audience, but teams working on specific things can use it to collaborate effectively.

We use Git to "save" the state of code if we are at a cross roads in the process, this allows us to return to that state later on should we make an error.

[Find an image to insert here]

We'll start with a cheat-sheet of the commands used most frequently, and note as we go...

== Setting up & Initializing a new Repository

From the local machine we initiliaze a new empty repository. This acts as a sort of wrapper that allows us to place pins at various points in the code. We do so with the following command:

[source, shell]
----
git init
----

It is important to know that the git init command will set a wrapper for the current directory from within which it is set, as well as anychild repositories beneath it.
Consider this:

[source, shell]
----
> Parent directory   <------- git init
> |
> |
> |------Child directory <------- this directory will now also be
                                  encapsulated by the wrapper

----

When we want to copy all the code from a remote repository into one that we have created locally, we use cloning. The name is pretty explanatory, it creates a clone (double) version of the code in the remote repository and copies it to our machine. To do this, we must have the url link of that code featured on a remote repo (or hosted location) so that we can tell Git where to clone it from, otherwise it cannot know. We use the following command:
[source, shell]
----
git clone [url]
----

Once we clone the code to our local we can now do what we please with it. However, if we would now like to host it on a remote repo or a CVCS then we must attach a new remote to it, as naturally the attached remote will be the one that it was originally cloned from.

[source, shell]
----
git clone [not_my_url]
git remote -v


>[not_my_url](fetch)
>[not_my_url](push)
----

We look closer at how to do this later, for now just remember that that's somebody else's url attached, not yours.


== Staging

So we have initialized an empty Git repository, meaning we now have a wrapper to track any changes that occur in our process.
We make some changes to our code and would like to save the current state of where things are. We can do a few things:

[source, shell]
----
git status
# to show modified files in the working directory, staged or not for the next commit

git add [file]
# we use this command to "stage" the state of a file to the next commit

git reset [file]
# we use this to unstage a file while retaining the changes in the working directory
# for instance: we have staged multiple files and would like to unstage just one in particular from the next commit <1>
git diff

git diff --staged
# we use this to visualize the difference between the current code state and what is staged but not yet committed

git commit -m "[some descriptive message]" <2>
# we use this to commit the staged content as a new commit "snapshot"
----

<1> Why might we do this? Well, when we make our commit messages we like each commit to encapsulate one particular thing at a time, one incremental step at a time: we want to make multiple small steps/commits rather than one big one, because this means that the process is more maintainable should something go wrong: we make one small change at a time, therefore each commit should be a grouping of changes that make sense to be together. Consider the following example:
- As a mechanic, someone brings us a car to fix
- The dashboard is not working
- We go through fixing each component of the electronics in the dashboard
- Each time we fix something we start the car to see if works
- We fix the windscreen wipers and the radio (without checking to start the car)
- The car is no longer working
- Because we did not check each incremental step we now do not know which fix caused the car to stop working.
- To keep it simple when we write the commit message we should not have to use the word "and" to describe what we have changed, if we did then its probably too long.

<2> Generally it is considered a better idea to use `git commit -v` (v stands for verbose) instead, as it allows us to stop and think about whether we are writing a meaningful commit message, whether the code is in a correct state ready for committing, and to peruse over the changes in the code. We stop and think for a moment not only because we are practitioners of zen, and meditation, but also because we want to consider whether returning to such a state would arouse confusion, or whether it is a safe place to return to. It's a little like jumping across stepping stones if you are lucky enough to be chosen as a participant of Takeshi's castle, you can stop at any stage - you just need to be sure that the stone you stop on is solid enough to hold your weight and that you can balance on it.

image::{sourcedir}/takeshi.jpg[scaledwidth=50%, align="center"]

== Branches & merging

A useful way to think about git version control is to consider the wrapper as a tree of sorts. The great thing about this is that if we want to start working on a feature or part of the code without affecting the current state of our code, we can create a branch. The root branch of a git wrapper is generally called 'main', but you can set it to whatever you want - previously it was called 'master' branch, but to get away frmo the master/slave langauge it was changed to the former. The root branch of the wrapper on this very project is called 'unbroken' for instance, as ideally the root branch is the only one that cannot, and communicating that it must not, be broken/corrupt. This is particularly useful when working as part of a team, and different pairs/squads/people of that team are working on different parts of the code. To avoid getting in each others hair code is written on separate branches and then merged back onto the main in pull request - which is where those writers request the incorporation of their newly written code into the main.

[insert an image of a tree with diverging branchs, but where those branches come back to join the main trunk]

[source, shell]
----
git branch
# to check branches, * appears aside the branch we are currently on

git branch [name-of-new-branch]
git checkout -b [name-of-new-branch]
# to create a new branches we have these options

git checkout [name-of-branch]
# to switch to another branch and check it out into working directory

git merge [name-of-branch]
# to merge the specified branch's history into the current one <1>

----

<1> Sometimes this can be a caveat, as changes are made to multiple branches at
the same time (by different people, or by us - if we are jumping between two or
more aspects of the code) then once we merge back onto the main we may have
repeated commit messages, and when looking back through our commit messages
things might look messy. To render them clean, we use `git rebase` instead, see below.

== Inspecting & Comparing

[source, shell]
----
git log
# to show all commits in the current branch's history <1>

git shortlog
# to view only the first line of each commit message
----
<1> Using git log shows the first line of the commit message followed by any
extraneous information we include within the verbose commit entry (`git commit
-v`).

As a convention that we try to follow, the first line of a given
commit message should not be greater than 50 characters long (4.75 is the
average length of a word in English). When reading the commit messages we
should be able to follow the narrative of how we came to be at any particular
state in the code. the commit message, if verbose should provide the 'who?
what? why? how?'.

[source, shell]
----
git log branchB..branchA
# to show the commits on branchA that are not on branchB

git diff branchB..branchA
# to show the diff of what is in branchA that is not in branchB

git show [SHA key] <1>
# show any object in Git in human-readable format
----
<1> This will only show the contents of the object in Git, meaning we will only be able to view the contents of the commit message and the diff (differences) from that state. In order to actually place ourselves at the very state of a particular message, we use: `git checkout [SHA key]`, once we do this we will be able to move around from within the code at that very state.

== Tracking Path Changes

[source, shell]
----
git rm [file]

git mv [existing-path][new-path]

git log --stat -M
----

== Ignoring Patterns

To prevent the staging or commit of certain files, we write a .gitignore file

----
logs/
*.notes
pattern*/
#Save a file with desired paterns as .gitignore with either direct string
matches or wildcard globs.

git config --gloabl core.excludesfile[file]
#system wide ignore pattern for all local repos
----

== Sharing & Updating

So now we arrive at how to change the remote address to which we will push the updated code. This so that others can write to it themselves.

[source]
----
git remote add [alias, usually origin][url]
# add a git URL as an alias

git fetch [alias]
#fetches down all the branches from that Git remote <1>

git merge[alias]/[branch]
# merge a remote branch into your current branch to bring it up to date

git push [alias][branch]
# Transmit local branch commits to the remote repository branch

git pull
# fetch and merge any commits from the tracking remote branch
----

<1> The difference between `git pull` vs `git fetch`
:vic-says:
You can use `git fetch` to know the changes done in the remote repo/branch since
your last pull. This is useful to allow for checking before doing an actual
pull, which could change files in your current branch and working copy (and
potentially lose your changes, etc).
If you do a fetch, you do not have to do an "actual pull", at least in the
terms of doing git pull literally.  Instead you can do a rebase or merge or
reset using the local reference, since you just got done doing the fetch part
of the pull command.
* https://www.freecodecamp.org/news/git-fetch-vs-pull/[FreeCodeCamp Explanation]
* https://scribe.rip/@sabbirhossain_70520/git-fetch-vs-git-pull-691823ed4239[A Medium Article]

== Rewriting History

Remember when we mentioned that merging made for sometimes messy commit history? This is the alternative which makes for much cleaner commit messages:

[source]
----
git rebase [branch]
# applies any commits of current branch ahead of specified one
# this will put the commit messages on top of the ones that already exist on another branch, but will allow us to not have duplicate messages in our commit history.

git rebase -i root
# we use when we really want to clean up our commit history <1>

git reset --hard [commit]
# clear staging area, rewrite working tree from specified commit
----

<1> The '-i' flag stands for interactive, we enter into this mode to pick specifically which messages in the history we want to change. As we go through, we either:
- leave commit message as be
- modify the prefix word with 'edit' :when we want to change the contents of the commit message
- modify the prefix word with 'squash' : when we want to "flatten"/erase that particular commit message; though be careful, doing so can cause the next commit object to break meaning that if you were to checkout the code at that particular state it may be missing some code or state required for it to function correctly.
[insert an image/or better yet an asciinema of this being done to some code]

== Making Temporary Commits

We use these when we need to temporarily store written files that have not been committed yet, for instance: if we would like to checkout another branch but have not committed changes made yet.

[source, shell]
----
git stash

git stash list

git stash pop

git stash drop
----

== Reverting Commits

To revert only a specific file from a previous commit message, we can do this:

[source, shell]
----
$ git checkout [revision_hash] [file_name]
----

This was taken from here:https://coderwall.com/p/dvdrzg/retrieve-single-file-from-old-commit-on-git
